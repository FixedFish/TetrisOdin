package main

import "core:fmt"
import "core:math/rand"
import rl "vendor:raylib"

GRID_WIDTH: i32 : 8
GRID_HEIGHT: i32 : 12
CELL_SIZE: i32 : 32

grid: [GRID_WIDTH][GRID_HEIGHT]GridCell
fall_timer: f32 = 0.0
fall_interval: f32 : 0.5

has_active_tetramino: bool = false
current_tetramino: Tetromino

Vector2i :: struct {
	x: i32,
	y: i32,
}

GridCell :: struct {
	occupied: bool,
	color:    rl.Color,
}

Tetromino :: struct {
	blocks:   []Vector2i,
	position: Vector2i,
	color:    rl.Color,
}

TetrominoType :: enum {
	I,
	O,
	T,
	S,
	Z,
	J,
	L,
}

init_grid :: proc() {
	for y in 0 ..< GRID_HEIGHT {
		for x in 0 ..< GRID_WIDTH {
			grid[x][y].occupied = false
			grid[x][y].color = rl.DARKGRAY
		}
	}
}

generate_random_tetramino :: proc() -> Tetromino {
	ttype: TetrominoType = rand.choice_enum(TetrominoType)
	fmt.print(ttype)
	return create_tetromino(ttype)
}

create_tetromino :: proc(ttype: TetrominoType) -> Tetromino {
	has_active_tetramino = true
	t: Tetromino
	switch ttype {
	case .I:
		t.blocks = {{0, 0}, {0, -1}, {0, -2}, {0, -3}}
		t.color = rl.BLUE
	case .O:
		t.blocks = {{0, 0}, {1, 0}, {0, 1}, {1, 1}}
		t.color = rl.YELLOW
	case .T:
		t.blocks = {{-1, 0}, {0, 0}, {1, 0}, {0, 1}}
		t.color = rl.PINK
	case .S:
		t.blocks = {{-1, 0}, {0, 0}, {0, -1}, {1, -1}}
		t.color = rl.RED
	case .Z:
		t.blocks = {{0, 0}, {1, 0}, {0, -1}, {-1, -1}}
		t.color = rl.LIME
	case .J:
		t.blocks = {{-1, 0}, {0, 0}, {0, -1}, {0, -2}}
		t.color = rl.PINK
	case .L:
		t.blocks = {{0, 0}, {1, 0}, {0, -1}, {0, -2}}
		t.color = rl.ORANGE
	}
	t.position = {3, 0}
	fmt.print(t.position)
	return t
}

draw_grid :: proc() {
	for y in 0 ..< GRID_HEIGHT {
		for x in 0 ..< GRID_WIDTH {
			cell: GridCell = grid[x][y]
			color: rl.Color = cell.color if cell.occupied else rl.RAYWHITE
			rl.DrawRectangle(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE - 1, CELL_SIZE - 1, color)
		}
	}
}

draw_tetramino :: proc(t: Tetromino) {
	if has_active_tetramino {
		for b in t.blocks {
			px: i32 = (t.position.x + b.x) * CELL_SIZE
			py: i32 = (t.position.y + b.y) * CELL_SIZE
			rl.DrawRectangle(px, py, CELL_SIZE - 1, CELL_SIZE - 1, t.color)
		}
	}
}

tetramino_to_grid :: proc(t: ^Tetromino) {
	for b in t.blocks {
		x: i32 = b.x + t.position.x
		y: i32 = b.y + t.position.y
		fmt.print("x: {}, y: {}\n", x, y)
		grid[x][y].occupied = true
	}
	has_active_tetramino = false
	fmt.print("Tetramino succesfuly locked on grid")
}

can_move_down :: proc(t: ^Tetromino) -> bool {
	for b in t.blocks {
		gx: i32 = b.x + t.position.x
		gy: i32 = b.y + t.position.y + 1

		if (gy >= GRID_HEIGHT - 5) || (grid[gx][gy].occupied) {return false}
	}
	return true
}

move_tetramino_down :: proc(t: ^Tetromino) {
	if has_active_tetramino {
		if can_move_down(t) {
			t.position.y += 1
		} else {
			tetramino_to_grid(t)
		}
	}
}

main :: proc() {
	defer rl.CloseWindow()
	rl.InitWindow(GRID_WIDTH * CELL_SIZE, GRID_HEIGHT * CELL_SIZE, "Tetris")
	rl.SetTargetFPS(60)

	init_grid()
	for !rl.WindowShouldClose() {
		defer rl.EndDrawing()
		dt := rl.GetFrameTime()
		fall_timer += dt

		if !(has_active_tetramino) {
			current_tetramino = generate_random_tetramino()
		}

		if fall_timer > 1.0 {
			fall_timer = 0.0
			move_tetramino_down(&current_tetramino)
		}
		rl.BeginDrawing()
		rl.ClearBackground(rl.BLACK)

		draw_grid()
		draw_tetramino(current_tetramino)
	}
}
